构造太菜了，多多练习涨涨脑子。

# [[POI 2013] GRA-Tower Defense Game](https://www.luogu.com.cn/problem/P3557)
一道水绿，一看是还以为攻击距离为 2 是指只能打到相距为 2 的点，画了一下样例以后发现不就是在一开始的基础上多走一步吗。

- 发现：或许在攻击距离为 1 的时候要好好考虑一下分配，可是当你发现攻击距离为 2 的话，随便怎么搞都一定不劣

大概口胡一下就是本来要选择的是 $u$，控制的点是集合 $v$，脑子里抽象一下一定是 1 ~ 3 的距离会摆放一个。  
但现在攻击距离为 2，每 2 个至少能控制 1 ~ 5 的距离，所以顺序随意摆放一定不劣。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
int n, m, k, cnt;
vector<int> G[N], ans;
bool vis[N];
void cover(int x) {
	for(int y : G[x]) {
		vis[y] = 1;
		for(int z : G[y])
			vis[z] = 1;
	}
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> k;
	for(int i = 1, u, v; i <= m; i ++) {
		cin >> u >> v;
		G[u].emplace_back(v), G[v].emplace_back(u);
	}
	for(int i = 1; i <= n; i ++) {
		if(!vis[i]) {
			vis[i] = true;
			cover(i);
			ans.emplace_back(i);
		}
	}
	cout << ans.size() << '\n';
	for(int it : ans) cout << it << ' ';
	return cout << '\n', 0;
}
```

# [树的重量](https://www.luogu.com.cn/problem/P1268)
神仙题，这道题让我知道了**画图找规律**的重要性。

一开始看到这么小的数据范围，想的竟然是枚举值域，真的唐。  
想了很久无果，果断看 TJ。  
看了以后：真的水。

- n = 2 的情况：显然 $G_{1, 2}$。
- n = 3 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1522.png)
  一眼发现答案就是蓝色这段的长度，那么记这段长度为 $l$，则 $l = \frac{G_{1, 3} + G_{2, 3} - G_{1, 2}}{2}$
- n = 4 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1523.png)
  这是一种情况，这一段的长度 $l = \frac{G_{1, 4} + G_{3, 4} - G_{3, 4}}{2}$，但是如果你把 4 看作在 1 和 2 上的话，算出来的 $l$ 就会是红色的那一段。
- n > 4 的情况：我们发现可以考虑去枚举当前加入的点 $i$ 所在段的位置 $j - 1, j$，然后通过前面发现的规律计算出最小值即可。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int n, G[N][N], ans;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(int i = 1; i < n; i ++)
		for(int j = i + 1; j <= n; j ++)
			cin >> G[i][j];
	ans = G[1][2];
	for(int i = 3, minv; i <= n; i ++) {
		minv = 0x3f3f3f3f;
		for(int j = 2; j < i; j ++) minv = min(minv, G[1][i] + G[j][i] - G[1][j] >> 1);
		ans += minv;
	}
	return cout << ans << '\n', 0;
}
```
# [【MX-X10-T3】[LSOT-4] 全国联赛？](https://www.luogu.com.cn/problem/P12007)
肯定被低估的一道绿题，在我看来至少都是蓝。

题意：给你个森林，让你用 n - m - 1 条边将其变成一棵树，并且树中任意 2 点的距离相加的和最小。

### 状态与转移

转换以后都有树了，那直接上树形 dp 呀。  
- 状态：$f_{root}$ 表示以 root 为根的最小答案，$g_{root}$ 表示以 root 为根每个点到 root 的距离和。
空有状态也不行，所以我们必须假设现在有一些东西，就比如合并 $u$ 和 $v$ 为根的 2 棵树，用 $w$ 来连接。
- 状态转移：
  $$f_{root} = f_u + f_v + g_u \times sz_v + g_v \times sz_u + sz_u \times sz_v \times w$$
先不忙考虑 $g$ 的转移，观察这个式子，你会发现对式子产生影响的只有 $g_u$，$g_v$，对于根的影响也只是它们，所以我们要尽可能减少 $g_u$ 和 $g_v$，那么 $u, v$ 分别选择 2 棵树的重心一定最优，故 $root$ 选择 $u$ 或者 $v$ 一定最优。

现在假设 $sz_u > sz_v$，则 $g$ 的状态转移：
$$g_{u'} = g_u + g_v + w \times sz_v$$  
$$g_{v'} = g_u + g_v + w \times sz_u$$

所以上面的一个式子就是 $g$ 的状态转移式。

一直转移直到只有 1 棵树即可。

### 初始化和细节

$g$ 的初始化就是一个很标准的换根 dp 初始化，直接 copy 一下即可。  
$w$ 按照从小到大的顺序进行添加，有一点启发式合并的味。

AC code:
```

```
