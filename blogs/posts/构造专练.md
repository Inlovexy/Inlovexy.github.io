构造太菜了，多多练习涨涨脑子。

# [[POI 2013] GRA-Tower Defense Game](https://www.luogu.com.cn/problem/P3557)
一道水绿，一看是还以为攻击距离为 2 是指只能打到相距为 2 的点，画了一下样例以后发现不就是在一开始的基础上多走一步吗。

- 发现：或许在攻击距离为 1 的时候要好好考虑一下分配，可是当你发现攻击距离为 2 的话，随便怎么搞都一定不劣

大概口胡一下就是本来要选择的是 $u$，控制的点是集合 $v$，脑子里抽象一下一定是 1 ~ 3 的距离会摆放一个。  
但现在攻击距离为 2，每 2 个至少能控制 1 ~ 5 的距离，所以顺序随意摆放一定不劣。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
int n, m, k, cnt;
vector<int> G[N], ans;
bool vis[N];
void cover(int x) {
	for(int y : G[x]) {
		vis[y] = 1;
		for(int z : G[y])
			vis[z] = 1;
	}
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> k;
	for(int i = 1, u, v; i <= m; i ++) {
		cin >> u >> v;
		G[u].emplace_back(v), G[v].emplace_back(u);
	}
	for(int i = 1; i <= n; i ++) {
		if(!vis[i]) {
			vis[i] = true;
			cover(i);
			ans.emplace_back(i);
		}
	}
	cout << ans.size() << '\n';
	for(int it : ans) cout << it << ' ';
	return cout << '\n', 0;
}
```

# [树的重量](https://www.luogu.com.cn/problem/P1268)
神仙题，这道题让我知道了**画图找规律**的重要性。

一开始看到这么小的数据范围，想的竟然是枚举值域，真的唐。  
想了很久无果，果断看 TJ。  
看了以后：真的水。

- n = 2 的情况：显然 $G_{1, 2}$。
- n = 3 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1522.png)
  一眼发现答案就是蓝色这段的长度，那么记这段长度为 $l$，则 $l = \frac{G_{1, 3} + G_{2, 3} - G_{1, 2}}{2}$
- n = 4 的情况：
  ![](https://cdn.luogu.com.cn/upload/pic/1523.png)
  这是一种情况，这一段的长度 $l = \frac{G_{1, 4} + G_{3, 4} - G_{3, 4}}{2}$，但是如果你把 4 看作在 1 和 2 上的话，算出来的 $l$ 就会是红色的那一段。
- n > 4 的情况：我们发现可以考虑去枚举当前加入的点 $i$ 所在段的位置 $j - 1, j$，然后通过前面发现的规律计算出最小值即可。

AC code:
```
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int n, G[N][N], ans;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(int i = 1; i < n; i ++)
		for(int j = i + 1; j <= n; j ++)
			cin >> G[i][j];
	ans = G[1][2];
	for(int i = 3, minv; i <= n; i ++) {
		minv = 0x3f3f3f3f;
		for(int j = 2; j < i; j ++) minv = min(minv, G[1][i] + G[j][i] - G[1][j] >> 1);
		ans += minv;
	}
	return cout << ans << '\n', 0;
}
```
