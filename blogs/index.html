<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>我的算法博客</title>

  <!-- 字体 -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Noto+Serif+SC&display=swap" rel="stylesheet">

  <!-- 关键：先加载 MathJax 核心 -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    // 配置 MathJax 优先解析 $ 和 $$
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$']],  // 仅保留 $ 作为行内公式标记（避免冲突）
        displayMath: [['$$', '$$']],  // 仅保留 $$ 作为块级公式标记
        processEscapes: true
      },
      startup: {
        pageReady: function() {
          return MathJax.startup.defaultPageReady();
        }
      }
    };
  </script>

  <!-- Markdown 解析（使用更稳定的版本） -->
  <script src="https://cdn.jsdelivr.net/npm/marked@4.0.2/marked.min.js"></script>

  <!-- 代码高亮 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <style>
    /* 基础样式保持不变 */
    :root {
      --primary: #4361ee;
      --text: #2b2d42;
      --bg: #f5f7ff;
      --card: #ffffff;
      --shadow: 0 4px 6px rgba(0,0,0,0.1);
      --radius: 8px;
    }

    body {
      font-family: 'Poppins', 'Noto Serif SC', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: var(--bg);
      color: var(--text);
      line-height: 1.8;
    }

    .post {
      background: var(--card);
      padding: 25px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 30px;
    }

    .post-title {
      color: var(--text);
      text-decoration: none;
      font-size: 1.5em;
      font-weight: 600;
    }

    /* 阅读器样式 */
    #reader {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: white;
      padding: 20px;
      overflow-y: auto;
    }

    #post-content {
      max-width: 800px;
      margin: 0 auto;
    }

    /* 公式样式 */
    .MathJax {
      font-size: 1.1em !important;
      margin: 0.5em 0 !important;
    }

    /* 其他样式保持不变... */
    .back-link {
      display: inline-block;
      margin: 30px 0;
      padding: 10px 20px;
      background: var(--primary);
      color: white;
      text-decoration: none;
      border-radius: 50px;
    }

    .theme-toggle {
      position: fixed;
      bottom: 20px; right: 20px;
      width: 50px; height: 50px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <h1>文章列表</h1>

  <div class="post">
    <div class="post-details">
      <div class="post-date">2025-08-10</div>
      <a href="javascript:loadPost('posts/a-s.md')" class="post-title">[A:S] 动态规划题解</a>
      <p>使用三维 DP 解决颜色球移动问题</p>
    </div>
  </div>

  <a href="../" class="back-link">← 返回首页</a>
  <button class="theme-toggle" id="themeToggle">🌓</button>

  <!-- 阅读器 -->
  <div id="reader">
    <button onclick="closeReader()">← 返回列表</button>
    <div id="post-content"></div>
  </div>

  <script>
    // 初始化代码高亮
    hljs.highlightAll();

    // 简化版加载函数（确保公式优先解析）
    function loadPost(url) {
      // 1. 显示阅读器
      document.getElementById('reader').style.display = 'block';
      const contentEl = document.getElementById('post-content');
      contentEl.innerHTML = '加载中...';

      // 2. 加载并解析 Markdown
      fetch(url)
        .then(r => r.text())
        .then(md => {
          // 关键：先替换公式标记为 MathJax 兼容格式（避免 marked 转义）
          let processedMd = md
            .replace(/\$\$(.*?)\$\$/g, (match, formula) => `$$${formula}$$`)  // 保留块级公式
            .replace(/\$(.*?)\$/g, (match, formula) => `$${formula}$`);      // 保留行内公式

          // 3. 解析 Markdown 并插入 DOM
          contentEl.innerHTML = marked.parse(processedMd);

          // 4. 高亮代码
          document.querySelectorAll('pre code').forEach(block => {
            hljs.highlightElement(block);
          });

          // 5. 强制 MathJax 重新解析公式（核心步骤）
          if (window.MathJax) {
            MathJax.typesetClear();
            MathJax.typeset([contentEl]);  // 直接渲染，不使用 Promise 避免延迟问题
          }
        })
        .catch(err => {
          contentEl.innerHTML = `加载失败: ${err.message}`;
        });
    }

    function closeReader() {
      document.getElementById('reader').style.display = 'none';
    }

    // 主题切换（简化版）
    document.getElementById('themeToggle').onclick = () => {
      document.body.style.backgroundColor = document.body.style.backgroundColor === '#121212' 
        ? '#f5f7ff' 
        : '#121212';
      document.body.style.color = document.body.style.color === '#f8f9fa' ? '#2b2d42' : '#f8f9fa';
    };
  </script>
</body>
</html>
